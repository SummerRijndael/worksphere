#!/usr/bin/env python3
"""
Session Security Pentest Script
Tests for session-related vulnerabilities
"""

import requests
import sys

base_url = "http://localhost:8000"

print("=" * 60)
print("Session Security Pentest")
print("=" * 60)

all_passed = True

# Test 1: Cookie Security Attributes
print("\n--- Test 1: Cookie Security Attributes ---")
try:
    session = requests.Session()
    response = session.get(f"{base_url}/sanctum/csrf-cookie")
    
    cookies_checked = 0
    for cookie in session.cookies:
        cookies_checked += 1
        issues = []
        
        # Check HttpOnly (most session cookies should have this)
        # Note: XSRF-TOKEN intentionally doesn't have HttpOnly so JS can read it
        if cookie.name != "XSRF-TOKEN" and not cookie.has_nonstandard_attr("HttpOnly"):
            # httponly is stored differently
            pass  # Will check via response headers
            
        # Check Secure flag (in production)
        if not cookie.secure and base_url.startswith("https"):
            issues.append("Missing Secure flag")
            
        # Check SameSite
        samesite = cookie.get_nonstandard_attr("SameSite")
        if not samesite:
            issues.append("Missing SameSite attribute")
            
        if issues:
            print(f"⚠️  Cookie '{cookie.name}': {', '.join(issues)}")
        else:
            print(f"✅ Cookie '{cookie.name}' has proper attributes")
            
    if cookies_checked == 0:
        print("ℹ️  No cookies found (may be expected for stateless API)")
        
except Exception as e:
    print(f"ERROR: {e}")
    all_passed = False

# Test 2: Session Fixation Prevention
print("\n--- Test 2: Session Fixation Prevention ---")
try:
    session = requests.Session()
    
    # Get initial session
    session.get(f"{base_url}/sanctum/csrf-cookie")
    initial_cookies = {c.name: c.value for c in session.cookies}
    
    # Simulate login
    response = session.post(
        f"{base_url}/api/login",
        headers={
            "Accept": "application/json", 
            "Content-Type": "application/json",
            "X-XSRF-TOKEN": initial_cookies.get("XSRF-TOKEN", "")
        },
        json={"email": "admin@example.com", "password": "password"}
    )
    
    post_login_cookies = {c.name: c.value for c in session.cookies}
    
    # Check if session ID changed after login
    session_cookie_name = "laravel_session"
    if session_cookie_name in initial_cookies and session_cookie_name in post_login_cookies:
        if initial_cookies[session_cookie_name] != post_login_cookies[session_cookie_name]:
            print("✅ PASSED: Session regenerated after login")
        else:
            print("⚠️  Session ID unchanged after login (potential fixation risk)")
    else:
        print("ℹ️  Session cookie not found or login failed")
        
except Exception as e:
    print(f"ERROR: {e}")

# Test 3: Concurrent Session Handling
print("\n--- Test 3: Session Information Exposure ---")
try:
    token = "1|ju4QGKgnsMeVcQl5Rhswp4Ad5GpNAaH4PDLzBZJOa98e71e3"
    
    response = requests.get(
        f"{base_url}/api/user/sessions",
        headers={
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
    )
    
    if response.status_code == 200:
        sessions = response.json()
        
        # Check what data is exposed
        if isinstance(sessions, list) and len(sessions) > 0:
            sample = sessions[0]
            sensitive_fields = ["password", "token", "secret", "hash"]
            exposed = [f for f in sensitive_fields if f in str(sample).lower()]
            
            if exposed:
                print(f"❌ FAILED: Sensitive fields exposed: {exposed}")
                all_passed = False
            else:
                print("✅ PASSED: Session data properly sanitized")
        else:
            print("ℹ️  No sessions returned or different format")
    else:
        print(f"ℹ️  Sessions endpoint returned: {response.status_code}")
        
except Exception as e:
    print(f"ERROR: {e}")

# Test 4: Session Hijacking Prevention Headers
print("\n--- Test 4: Security Headers for Session Protection ---")
try:
    response = requests.get(
        f"{base_url}/api/user",
        headers={
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
    )
    
    required_headers = {
        "X-Content-Type-Options": "nosniff",
        "X-Frame-Options": ["DENY", "SAMEORIGIN"],
    }
    
    for header, expected in required_headers.items():
        actual = response.headers.get(header, "")
        if isinstance(expected, list):
            if actual in expected:
                print(f"✅ {header}: {actual}")
            elif actual:
                print(f"⚠️  {header}: {actual} (expected one of {expected})")
            else:
                print(f"⚠️  {header}: Missing")
        else:
            if actual == expected:
                print(f"✅ {header}: {actual}")
            elif actual:
                print(f"⚠️  {header}: {actual} (expected {expected})")
            else:
                print(f"⚠️  {header}: Missing")
                
except Exception as e:
    print(f"ERROR: {e}")

# Test 5: Logout Invalidation
print("\n--- Test 5: Logout Token Invalidation ---")
try:
    # This test would require a fresh token to properly test
    # For now, we verify the logout endpoint exists and responds correctly
    
    response = requests.post(
        f"{base_url}/api/logout",
        headers={
            "Authorization": f"Bearer {token}",
            "Accept": "application/json"
        }
    )
    
    if response.status_code in [200, 204]:
        print("✅ Logout endpoint responds correctly")
    elif response.status_code == 401:
        print("ℹ️  Token already invalid or expired")
    else:
        print(f"⚠️  Logout returned: {response.status_code}")
        
except Exception as e:
    print(f"ERROR: {e}")

print("\n" + "=" * 60)
if all_passed:
    print("✅ All Session Security Tests Passed!")
else:
    print("⚠️  Some Session Security Tests Need Review")
print("=" * 60)

sys.exit(0 if all_passed else 1)
